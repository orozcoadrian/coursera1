<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mylcov.info - /usr/include/google/protobuf/stubs/common.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">usr/include/google/protobuf/stubs</a> - common.h<span style="font-size: 80%;"> (source / <a href="common.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mylcov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2013-08-04</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : // Protocol Buffers - Google's data interchange format</a>
<span class="lineNum">       2 </span>                :            : // Copyright 2008 Google Inc.  All rights reserved.
<span class="lineNum">       3 </span>                :            : // http://code.google.com/p/protobuf/
<span class="lineNum">       4 </span>                :            : //
<span class="lineNum">       5 </span>                :            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>                :            : // modification, are permitted provided that the following conditions are
<span class="lineNum">       7 </span>                :            : // met:
<span class="lineNum">       8 </span>                :            : //
<span class="lineNum">       9 </span>                :            : //     * Redistributions of source code must retain the above copyright
<span class="lineNum">      10 </span>                :            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      11 </span>                :            : //     * Redistributions in binary form must reproduce the above
<span class="lineNum">      12 </span>                :            : // copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      13 </span>                :            : // in the documentation and/or other materials provided with the
<span class="lineNum">      14 </span>                :            : // distribution.
<span class="lineNum">      15 </span>                :            : //     * Neither the name of Google Inc. nor the names of its
<span class="lineNum">      16 </span>                :            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      17 </span>                :            : // this software without specific prior written permission.
<span class="lineNum">      18 </span>                :            : //
<span class="lineNum">      19 </span>                :            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      20 </span>                :            : // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      21 </span>                :            : // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      22 </span>                :            : // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      23 </span>                :            : // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      24 </span>                :            : // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      25 </span>                :            : // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      26 </span>                :            : // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      27 </span>                :            : // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      28 </span>                :            : // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      29 </span>                :            : // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      30 </span>                :            : 
<span class="lineNum">      31 </span>                :            : // Author: kenton@google.com (Kenton Varda) and others
<span class="lineNum">      32 </span>                :            : //
<span class="lineNum">      33 </span>                :            : // Contains basic types and utilities used by the rest of the library.
<span class="lineNum">      34 </span>                :            : 
<span class="lineNum">      35 </span>                :            : #ifndef GOOGLE_PROTOBUF_COMMON_H__
<span class="lineNum">      36 </span>                :            : #define GOOGLE_PROTOBUF_COMMON_H__
<span class="lineNum">      37 </span>                :            : 
<span class="lineNum">      38 </span>                :            : #include &lt;assert.h&gt;
<span class="lineNum">      39 </span>                :            : #include &lt;stdlib.h&gt;
<span class="lineNum">      40 </span>                :            : #include &lt;cstddef&gt;
<span class="lineNum">      41 </span>                :            : #include &lt;string&gt;
<span class="lineNum">      42 </span>                :            : #include &lt;string.h&gt;
<span class="lineNum">      43 </span>                :            : #if defined(__osf__)
<span class="lineNum">      44 </span>                :            : // Tru64 lacks stdint.h, but has inttypes.h which defines a superset of
<span class="lineNum">      45 </span>                :            : // what stdint.h would define.
<span class="lineNum">      46 </span>                :            : #include &lt;inttypes.h&gt;
<span class="lineNum">      47 </span>                :            : #elif !defined(_MSC_VER)
<span class="lineNum">      48 </span>                :            : #include &lt;stdint.h&gt;
<span class="lineNum">      49 </span>                :            : #endif
<span class="lineNum">      50 </span>                :            : 
<span class="lineNum">      51 </span>                :            : #if defined(_MSC_VER) &amp;&amp; defined(_CPPUNWIND)
<span class="lineNum">      52 </span>                :            :   #define PROTOBUF_USE_EXCEPTIONS
<span class="lineNum">      53 </span>                :            : #elif defined(__EXCEPTIONS)
<span class="lineNum">      54 </span>                :            :   #define PROTOBUF_USE_EXCEPTIONS
<span class="lineNum">      55 </span>                :            : #endif
<span class="lineNum">      56 </span>                :            : #ifdef PROTOBUF_USE_EXCEPTIONS
<span class="lineNum">      57 </span>                :            : #include &lt;exception&gt;
<span class="lineNum">      58 </span>                :            : #endif
<span class="lineNum">      59 </span>                :            : 
<span class="lineNum">      60 </span>                :            : #if defined(_WIN32) &amp;&amp; defined(GetMessage)
<span class="lineNum">      61 </span>                :            : // Allow GetMessage to be used as a valid method name in protobuf classes.
<span class="lineNum">      62 </span>                :            : // windows.h defines GetMessage() as a macro.  Let's re-define it as an inline
<span class="lineNum">      63 </span>                :            : // function.  The inline function should be equivalent for C++ users.
<span class="lineNum">      64 </span>                :            : inline BOOL GetMessage_Win32(
<span class="lineNum">      65 </span>                :            :     LPMSG lpMsg, HWND hWnd,
<span class="lineNum">      66 </span>                :            :     UINT wMsgFilterMin, UINT wMsgFilterMax) {
<span class="lineNum">      67 </span>                :            :   return GetMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
<span class="lineNum">      68 </span>                :            : }
<span class="lineNum">      69 </span>                :            : #undef GetMessage
<span class="lineNum">      70 </span>                :            : inline BOOL GetMessage(
<span class="lineNum">      71 </span>                :            :     LPMSG lpMsg, HWND hWnd,
<span class="lineNum">      72 </span>                :            :     UINT wMsgFilterMin, UINT wMsgFilterMax) {
<span class="lineNum">      73 </span>                :            :   return GetMessage_Win32(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
<span class="lineNum">      74 </span>                :            : }
<span class="lineNum">      75 </span>                :            : #endif
<span class="lineNum">      76 </span>                :            : 
<span class="lineNum">      77 </span>                :            : 
<span class="lineNum">      78 </span>                :            : namespace std {}
<span class="lineNum">      79 </span>                :            : 
<span class="lineNum">      80 </span>                :            : namespace google {
<span class="lineNum">      81 </span>                :            : namespace protobuf {
<span class="lineNum">      82 </span>                :            : 
<span class="lineNum">      83 </span>                :            : #undef GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
<span class="lineNum">      84 </span>                :            : #define GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(TypeName)    \
<span class="lineNum">      85 </span>                :            :   TypeName(const TypeName&amp;);                           \
<span class="lineNum">      86 </span>                :            :   void operator=(const TypeName&amp;)
<span class="lineNum">      87 </span>                :            : 
<span class="lineNum">      88 </span>                :            : #if defined(_MSC_VER) &amp;&amp; defined(PROTOBUF_USE_DLLS)
<span class="lineNum">      89 </span>                :            :   #ifdef LIBPROTOBUF_EXPORTS
<span class="lineNum">      90 </span>                :            :     #define LIBPROTOBUF_EXPORT __declspec(dllexport)
<span class="lineNum">      91 </span>                :            :   #else
<span class="lineNum">      92 </span>                :            :     #define LIBPROTOBUF_EXPORT __declspec(dllimport)
<span class="lineNum">      93 </span>                :            :   #endif
<span class="lineNum">      94 </span>                :            :   #ifdef LIBPROTOC_EXPORTS
<span class="lineNum">      95 </span>                :            :     #define LIBPROTOC_EXPORT   __declspec(dllexport)
<span class="lineNum">      96 </span>                :            :   #else
<span class="lineNum">      97 </span>                :            :     #define LIBPROTOC_EXPORT   __declspec(dllimport)
<span class="lineNum">      98 </span>                :            :   #endif
<span class="lineNum">      99 </span>                :            : #else
<span class="lineNum">     100 </span>                :            :   #define LIBPROTOBUF_EXPORT
<span class="lineNum">     101 </span>                :            :   #define LIBPROTOC_EXPORT
<span class="lineNum">     102 </span>                :            : #endif
<span class="lineNum">     103 </span>                :            : 
<span class="lineNum">     104 </span>                :            : namespace internal {
<span class="lineNum">     105 </span>                :            : 
<span class="lineNum">     106 </span>                :            : // Some of these constants are macros rather than const ints so that they can
<span class="lineNum">     107 </span>                :            : // be used in #if directives.
<span class="lineNum">     108 </span>                :            : 
<span class="lineNum">     109 </span>                :            : // The current version, represented as a single integer to make comparison
<span class="lineNum">     110 </span>                :            : // easier:  major * 10^6 + minor * 10^3 + micro
<span class="lineNum">     111 </span>                :            : #define GOOGLE_PROTOBUF_VERSION 2004001
<span class="lineNum">     112 </span>                :            : 
<span class="lineNum">     113 </span>                :            : // The minimum library version which works with the current version of the
<span class="lineNum">     114 </span>                :            : // headers.
<span class="lineNum">     115 </span>                :            : #define GOOGLE_PROTOBUF_MIN_LIBRARY_VERSION 2004000
<span class="lineNum">     116 </span>                :            : 
<span class="lineNum">     117 </span>                :            : // The minimum header version which works with the current version of
<span class="lineNum">     118 </span>                :            : // the library.  This constant should only be used by protoc's C++ code
<span class="lineNum">     119 </span>                :            : // generator.
<span class="lineNum">     120 </span>                :            : static const int kMinHeaderVersionForLibrary = 2004000;
<span class="lineNum">     121 </span>                :            : 
<span class="lineNum">     122 </span>                :            : // The minimum protoc version which works with the current version of the
<span class="lineNum">     123 </span>                :            : // headers.
<span class="lineNum">     124 </span>                :            : #define GOOGLE_PROTOBUF_MIN_PROTOC_VERSION 2004000
<span class="lineNum">     125 </span>                :            : 
<span class="lineNum">     126 </span>                :            : // The minimum header version which works with the current version of
<span class="lineNum">     127 </span>                :            : // protoc.  This constant should only be used in VerifyVersion().
<span class="lineNum">     128 </span>                :            : static const int kMinHeaderVersionForProtoc = 2004000;
<span class="lineNum">     129 </span>                :            : 
<span class="lineNum">     130 </span>                :            : // Verifies that the headers and libraries are compatible.  Use the macro
<span class="lineNum">     131 </span>                :            : // below to call this.
<span class="lineNum">     132 </span>                :            : void LIBPROTOBUF_EXPORT VerifyVersion(int headerVersion, int minLibraryVersion,
<span class="lineNum">     133 </span>                :            :                                       const char* filename);
<span class="lineNum">     134 </span>                :            : 
<span class="lineNum">     135 </span>                :            : // Converts a numeric version number to a string.
<span class="lineNum">     136 </span>                :            : std::string LIBPROTOBUF_EXPORT VersionString(int version);
<span class="lineNum">     137 </span>                :            : 
<span class="lineNum">     138 </span>                :            : }  // namespace internal
<span class="lineNum">     139 </span>                :            : 
<span class="lineNum">     140 </span>                :            : // Place this macro in your main() function (or somewhere before you attempt
<span class="lineNum">     141 </span>                :            : // to use the protobuf library) to verify that the version you link against
<span class="lineNum">     142 </span>                :            : // matches the headers you compiled against.  If a version mismatch is
<span class="lineNum">     143 </span>                :            : // detected, the process will abort.
<span class="lineNum">     144 </span>                :            : #define GOOGLE_PROTOBUF_VERIFY_VERSION                                    \
<span class="lineNum">     145 </span>                :            :   ::google::protobuf::internal::VerifyVersion(                            \
<span class="lineNum">     146 </span>                :            :     GOOGLE_PROTOBUF_VERSION, GOOGLE_PROTOBUF_MIN_LIBRARY_VERSION,         \
<span class="lineNum">     147 </span>                :            :     __FILE__)
<span class="lineNum">     148 </span>                :            : 
<span class="lineNum">     149 </span>                :            : // ===================================================================
<span class="lineNum">     150 </span>                :            : // from google3/base/port.h
<span class="lineNum">     151 </span>                :            : 
<span class="lineNum">     152 </span>                :            : typedef unsigned int uint;
<span class="lineNum">     153 </span>                :            : 
<span class="lineNum">     154 </span>                :            : #ifdef _MSC_VER
<span class="lineNum">     155 </span>                :            : typedef __int8  int8;
<span class="lineNum">     156 </span>                :            : typedef __int16 int16;
<span class="lineNum">     157 </span>                :            : typedef __int32 int32;
<span class="lineNum">     158 </span>                :            : typedef __int64 int64;
<span class="lineNum">     159 </span>                :            : 
<span class="lineNum">     160 </span>                :            : typedef unsigned __int8  uint8;
<span class="lineNum">     161 </span>                :            : typedef unsigned __int16 uint16;
<span class="lineNum">     162 </span>                :            : typedef unsigned __int32 uint32;
<span class="lineNum">     163 </span>                :            : typedef unsigned __int64 uint64;
<span class="lineNum">     164 </span>                :            : #else
<span class="lineNum">     165 </span>                :            : typedef int8_t  int8;
<span class="lineNum">     166 </span>                :            : typedef int16_t int16;
<span class="lineNum">     167 </span>                :            : typedef int32_t int32;
<span class="lineNum">     168 </span>                :            : typedef int64_t int64;
<span class="lineNum">     169 </span>                :            : 
<span class="lineNum">     170 </span>                :            : typedef uint8_t  uint8;
<span class="lineNum">     171 </span>                :            : typedef uint16_t uint16;
<span class="lineNum">     172 </span>                :            : typedef uint32_t uint32;
<span class="lineNum">     173 </span>                :            : typedef uint64_t uint64;
<span class="lineNum">     174 </span>                :            : #endif
<span class="lineNum">     175 </span>                :            : 
<span class="lineNum">     176 </span>                :            : // long long macros to be used because gcc and vc++ use different suffixes,
<span class="lineNum">     177 </span>                :            : // and different size specifiers in format strings
<span class="lineNum">     178 </span>                :            : #undef GOOGLE_LONGLONG
<span class="lineNum">     179 </span>                :            : #undef GOOGLE_ULONGLONG
<span class="lineNum">     180 </span>                :            : #undef GOOGLE_LL_FORMAT
<span class="lineNum">     181 </span>                :            : 
<span class="lineNum">     182 </span>                :            : #ifdef _MSC_VER
<span class="lineNum">     183 </span>                :            : #define GOOGLE_LONGLONG(x) x##I64
<span class="lineNum">     184 </span>                :            : #define GOOGLE_ULONGLONG(x) x##UI64
<span class="lineNum">     185 </span>                :            : #define GOOGLE_LL_FORMAT &quot;I64&quot;  // As in printf(&quot;%I64d&quot;, ...)
<span class="lineNum">     186 </span>                :            : #else
<span class="lineNum">     187 </span>                :            : #define GOOGLE_LONGLONG(x) x##LL
<span class="lineNum">     188 </span>                :            : #define GOOGLE_ULONGLONG(x) x##ULL
<span class="lineNum">     189 </span>                :            : #define GOOGLE_LL_FORMAT &quot;ll&quot;  // As in &quot;%lld&quot;. Note that &quot;q&quot; is poor form also.
<span class="lineNum">     190 </span>                :            : #endif
<span class="lineNum">     191 </span>                :            : 
<span class="lineNum">     192 </span>                :            : static const int32 kint32max = 0x7FFFFFFF;
<span class="lineNum">     193 </span>                :            : static const int32 kint32min = -kint32max - 1;
<span class="lineNum">     194 </span>                :            : static const int64 kint64max = GOOGLE_LONGLONG(0x7FFFFFFFFFFFFFFF);
<span class="lineNum">     195 </span>                :            : static const int64 kint64min = -kint64max - 1;
<span class="lineNum">     196 </span>                :            : static const uint32 kuint32max = 0xFFFFFFFFu;
<span class="lineNum">     197 </span>                :            : static const uint64 kuint64max = GOOGLE_ULONGLONG(0xFFFFFFFFFFFFFFFF);
<span class="lineNum">     198 </span>                :            : 
<span class="lineNum">     199 </span>                :            : // -------------------------------------------------------------------
<span class="lineNum">     200 </span>                :            : // Annotations:  Some parts of the code have been annotated in ways that might
<span class="lineNum">     201 </span>                :            : //   be useful to some compilers or tools, but are not supported universally.
<span class="lineNum">     202 </span>                :            : //   You can #define these annotations yourself if the default implementation
<span class="lineNum">     203 </span>                :            : //   is not right for you.
<span class="lineNum">     204 </span>                :            : 
<span class="lineNum">     205 </span>                :            : #ifndef GOOGLE_ATTRIBUTE_ALWAYS_INLINE
<span class="lineNum">     206 </span>                :            : #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 ||(__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 1))
<span class="lineNum">     207 </span>                :            : // For functions we want to force inline.
<span class="lineNum">     208 </span>                :            : // Introduced in gcc 3.1.
<span class="lineNum">     209 </span>                :            : #define GOOGLE_ATTRIBUTE_ALWAYS_INLINE __attribute__ ((always_inline))
<span class="lineNum">     210 </span>                :            : #else
<span class="lineNum">     211 </span>                :            : // Other compilers will have to figure it out for themselves.
<span class="lineNum">     212 </span>                :            : #define GOOGLE_ATTRIBUTE_ALWAYS_INLINE
<span class="lineNum">     213 </span>                :            : #endif
<span class="lineNum">     214 </span>                :            : #endif
<span class="lineNum">     215 </span>                :            : 
<span class="lineNum">     216 </span>                :            : #ifndef GOOGLE_ATTRIBUTE_DEPRECATED
<span class="lineNum">     217 </span>                :            : #ifdef __GNUC__
<span class="lineNum">     218 </span>                :            : // If the method/variable/type is used anywhere, produce a warning.
<span class="lineNum">     219 </span>                :            : #define GOOGLE_ATTRIBUTE_DEPRECATED __attribute__((deprecated))
<span class="lineNum">     220 </span>                :            : #else
<span class="lineNum">     221 </span>                :            : #define GOOGLE_ATTRIBUTE_DEPRECATED
<span class="lineNum">     222 </span>                :            : #endif
<span class="lineNum">     223 </span>                :            : #endif
<span class="lineNum">     224 </span>                :            : 
<span class="lineNum">     225 </span>                :            : #ifndef GOOGLE_PREDICT_TRUE
<span class="lineNum">     226 </span>                :            : #ifdef __GNUC__
<span class="lineNum">     227 </span>                :            : // Provided at least since GCC 3.0.
<span class="lineNum">     228 </span>                :            : #define GOOGLE_PREDICT_TRUE(x) (__builtin_expect(!!(x), 1))
<span class="lineNum">     229 </span>                :            : #else
<span class="lineNum">     230 </span>                :            : #define GOOGLE_PREDICT_TRUE
<span class="lineNum">     231 </span>                :            : #endif
<span class="lineNum">     232 </span>                :            : #endif
<span class="lineNum">     233 </span>                :            : 
<span class="lineNum">     234 </span>                :            : // Delimits a block of code which may write to memory which is simultaneously
<span class="lineNum">     235 </span>                :            : // written by other threads, but which has been determined to be thread-safe
<span class="lineNum">     236 </span>                :            : // (e.g. because it is an idempotent write).
<span class="lineNum">     237 </span>                :            : #ifndef GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN
<span class="lineNum">     238 </span>                :            : #define GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN()
<span class="lineNum">     239 </span>                :            : #endif
<span class="lineNum">     240 </span>                :            : #ifndef GOOGLE_SAFE_CONCURRENT_WRITES_END
<span class="lineNum">     241 </span>                :            : #define GOOGLE_SAFE_CONCURRENT_WRITES_END()
<span class="lineNum">     242 </span>                :            : #endif
<span class="lineNum">     243 </span>                :            : 
<span class="lineNum">     244 </span>                :            : // ===================================================================
<span class="lineNum">     245 </span>                :            : // from google3/base/basictypes.h
<span class="lineNum">     246 </span>                :            : 
<span class="lineNum">     247 </span>                :            : // The GOOGLE_ARRAYSIZE(arr) macro returns the # of elements in an array arr.
<span class="lineNum">     248 </span>                :            : // The expression is a compile-time constant, and therefore can be
<span class="lineNum">     249 </span>                :            : // used in defining new arrays, for example.
<span class="lineNum">     250 </span>                :            : //
<span class="lineNum">     251 </span>                :            : // GOOGLE_ARRAYSIZE catches a few type errors.  If you see a compiler error
<span class="lineNum">     252 </span>                :            : //
<span class="lineNum">     253 </span>                :            : //   &quot;warning: division by zero in ...&quot;
<span class="lineNum">     254 </span>                :            : //
<span class="lineNum">     255 </span>                :            : // when using GOOGLE_ARRAYSIZE, you are (wrongfully) giving it a pointer.
<span class="lineNum">     256 </span>                :            : // You should only use GOOGLE_ARRAYSIZE on statically allocated arrays.
<span class="lineNum">     257 </span>                :            : //
<span class="lineNum">     258 </span>                :            : // The following comments are on the implementation details, and can
<span class="lineNum">     259 </span>                :            : // be ignored by the users.
<span class="lineNum">     260 </span>                :            : //
<span class="lineNum">     261 </span>                :            : // ARRAYSIZE(arr) works by inspecting sizeof(arr) (the # of bytes in
<span class="lineNum">     262 </span>                :            : // the array) and sizeof(*(arr)) (the # of bytes in one array
<span class="lineNum">     263 </span>                :            : // element).  If the former is divisible by the latter, perhaps arr is
<span class="lineNum">     264 </span>                :            : // indeed an array, in which case the division result is the # of
<span class="lineNum">     265 </span>                :            : // elements in the array.  Otherwise, arr cannot possibly be an array,
<span class="lineNum">     266 </span>                :            : // and we generate a compiler error to prevent the code from
<span class="lineNum">     267 </span>                :            : // compiling.
<span class="lineNum">     268 </span>                :            : //
<span class="lineNum">     269 </span>                :            : // Since the size of bool is implementation-defined, we need to cast
<span class="lineNum">     270 </span>                :            : // !(sizeof(a) &amp; sizeof(*(a))) to size_t in order to ensure the final
<span class="lineNum">     271 </span>                :            : // result has type size_t.
<span class="lineNum">     272 </span>                :            : //
<span class="lineNum">     273 </span>                :            : // This macro is not perfect as it wrongfully accepts certain
<span class="lineNum">     274 </span>                :            : // pointers, namely where the pointer size is divisible by the pointee
<span class="lineNum">     275 </span>                :            : // size.  Since all our code has to go through a 32-bit compiler,
<span class="lineNum">     276 </span>                :            : // where a pointer is 4 bytes, this means all pointers to a type whose
<span class="lineNum">     277 </span>                :            : // size is 3 or greater than 4 will be (righteously) rejected.
<span class="lineNum">     278 </span>                :            : //
<span class="lineNum">     279 </span>                :            : // Kudos to Jorg Brown for this simple and elegant implementation.
<span class="lineNum">     280 </span>                :            : 
<span class="lineNum">     281 </span>                :            : #undef GOOGLE_ARRAYSIZE
<span class="lineNum">     282 </span>                :            : #define GOOGLE_ARRAYSIZE(a) \
<span class="lineNum">     283 </span>                :            :   ((sizeof(a) / sizeof(*(a))) / \
<span class="lineNum">     284 </span>                :            :    static_cast&lt;size_t&gt;(!(sizeof(a) % sizeof(*(a)))))
<span class="lineNum">     285 </span>                :            : 
<span class="lineNum">     286 </span>                :            : namespace internal {
<span class="lineNum">     287 </span>                :            : 
<span class="lineNum">     288 </span>                :            : // Use implicit_cast as a safe version of static_cast or const_cast
<span class="lineNum">     289 </span>                :            : // for upcasting in the type hierarchy (i.e. casting a pointer to Foo
<span class="lineNum">     290 </span>                :            : // to a pointer to SuperclassOfFoo or casting a pointer to Foo to
<span class="lineNum">     291 </span>                :            : // a const pointer to Foo).
<span class="lineNum">     292 </span>                :            : // When you use implicit_cast, the compiler checks that the cast is safe.
<span class="lineNum">     293 </span>                :            : // Such explicit implicit_casts are necessary in surprisingly many
<span class="lineNum">     294 </span>                :            : // situations where C++ demands an exact type match instead of an
<span class="lineNum">     295 </span>                :            : // argument type convertable to a target type.
<span class="lineNum">     296 </span>                :            : //
<span class="lineNum">     297 </span>                :            : // The From type can be inferred, so the preferred syntax for using
<span class="lineNum">     298 </span>                :            : // implicit_cast is the same as for static_cast etc.:
<span class="lineNum">     299 </span>                :            : //
<span class="lineNum">     300 </span>                :            : //   implicit_cast&lt;ToType&gt;(expr)
<span class="lineNum">     301 </span>                :            : //
<span class="lineNum">     302 </span>                :            : // implicit_cast would have been part of the C++ standard library,
<span class="lineNum">     303 </span>                :            : // but the proposal was submitted too late.  It will probably make
<span class="lineNum">     304 </span>                :            : // its way into the language in the future.
<span class="lineNum">     305 </span>                :            : template&lt;typename To, typename From&gt;
<span class="lineNum">     306 </span>                :            : inline To implicit_cast(From const &amp;f) {
<span class="lineNum">     307 </span>                :            :   return f;
<span class="lineNum">     308 </span>                :            : }
<span class="lineNum">     309 </span>                :            : 
<span class="lineNum">     310 </span>                :            : // When you upcast (that is, cast a pointer from type Foo to type
<span class="lineNum">     311 </span>                :            : // SuperclassOfFoo), it's fine to use implicit_cast&lt;&gt;, since upcasts
<span class="lineNum">     312 </span>                :            : // always succeed.  When you downcast (that is, cast a pointer from
<span class="lineNum">     313 </span>                :            : // type Foo to type SubclassOfFoo), static_cast&lt;&gt; isn't safe, because
<span class="lineNum">     314 </span>                :            : // how do you know the pointer is really of type SubclassOfFoo?  It
<span class="lineNum">     315 </span>                :            : // could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,
<span class="lineNum">     316 </span>                :            : // when you downcast, you should use this macro.  In debug mode, we
<span class="lineNum">     317 </span>                :            : // use dynamic_cast&lt;&gt; to double-check the downcast is legal (we die
<span class="lineNum">     318 </span>                :            : // if it's not).  In normal mode, we do the efficient static_cast&lt;&gt;
<span class="lineNum">     319 </span>                :            : // instead.  Thus, it's important to test in debug mode to make sure
<span class="lineNum">     320 </span>                :            : // the cast is legal!
<span class="lineNum">     321 </span>                :            : //    This is the only place in the code we should use dynamic_cast&lt;&gt;.
<span class="lineNum">     322 </span>                :            : // In particular, you SHOULDN'T be using dynamic_cast&lt;&gt; in order to
<span class="lineNum">     323 </span>                :            : // do RTTI (eg code like this:
<span class="lineNum">     324 </span>                :            : //    if (dynamic_cast&lt;Subclass1&gt;(foo)) HandleASubclass1Object(foo);
<span class="lineNum">     325 </span>                :            : //    if (dynamic_cast&lt;Subclass2&gt;(foo)) HandleASubclass2Object(foo);
<span class="lineNum">     326 </span>                :            : // You should design the code some other way not to need this.
<span class="lineNum">     327 </span>                :            : 
<span class="lineNum">     328 </span>                :            : template&lt;typename To, typename From&gt;     // use like this: down_cast&lt;T*&gt;(foo);
<span class="lineNum">     329 </span>                :            : inline To down_cast(From* f) {                   // so we only accept pointers
<span class="lineNum">     330 </span>                :            :   // Ensures that To is a sub-type of From *.  This test is here only
<span class="lineNum">     331 </span>                :            :   // for compile-time type checking, and has no overhead in an
<span class="lineNum">     332 </span>                :            :   // optimized build at run-time, as it will be optimized away
<span class="lineNum">     333 </span>                :            :   // completely.
<span class="lineNum">     334 </span>                :            :   if (false) {
<span class="lineNum">     335 </span>                :            :     implicit_cast&lt;From*, To&gt;(0);
<span class="lineNum">     336 </span>                :            :   }
<span class="lineNum">     337 </span>                :            : 
<span class="lineNum">     338 </span>                :            : #if !defined(NDEBUG) &amp;&amp; !defined(GOOGLE_PROTOBUF_NO_RTTI)
<span class="lineNum">     339 </span>                :            :   assert(f == NULL || dynamic_cast&lt;To&gt;(f) != NULL);  // RTTI: debug mode only!
<span class="lineNum">     340 </span>                :            : #endif
<span class="lineNum">     341 </span>                :            :   return static_cast&lt;To&gt;(f);
<span class="lineNum">     342 </span>                :            : }
<span class="lineNum">     343 </span>                :            : 
<span class="lineNum">     344 </span>                :            : }  // namespace internal
<span class="lineNum">     345 </span>                :            : 
<span class="lineNum">     346 </span>                :            : // We made these internal so that they would show up as such in the docs,
<span class="lineNum">     347 </span>                :            : // but we don't want to stick &quot;internal::&quot; in front of them everywhere.
<span class="lineNum">     348 </span>                :            : using internal::implicit_cast;
<span class="lineNum">     349 </span>                :            : using internal::down_cast;
<span class="lineNum">     350 </span>                :            : 
<span class="lineNum">     351 </span>                :            : // The COMPILE_ASSERT macro can be used to verify that a compile time
<span class="lineNum">     352 </span>                :            : // expression is true. For example, you could use it to verify the
<span class="lineNum">     353 </span>                :            : // size of a static array:
<span class="lineNum">     354 </span>                :            : //
<span class="lineNum">     355 </span>                :            : //   COMPILE_ASSERT(ARRAYSIZE(content_type_names) == CONTENT_NUM_TYPES,
<span class="lineNum">     356 </span>                :            : //                  content_type_names_incorrect_size);
<span class="lineNum">     357 </span>                :            : //
<span class="lineNum">     358 </span>                :            : // or to make sure a struct is smaller than a certain size:
<span class="lineNum">     359 </span>                :            : //
<span class="lineNum">     360 </span>                :            : //   COMPILE_ASSERT(sizeof(foo) &lt; 128, foo_too_large);
<span class="lineNum">     361 </span>                :            : //
<span class="lineNum">     362 </span>                :            : // The second argument to the macro is the name of the variable. If
<span class="lineNum">     363 </span>                :            : // the expression is false, most compilers will issue a warning/error
<span class="lineNum">     364 </span>                :            : // containing the name of the variable.
<span class="lineNum">     365 </span>                :            : 
<span class="lineNum">     366 </span>                :            : namespace internal {
<span class="lineNum">     367 </span>                :            : 
<span class="lineNum">     368 </span>                :            : template &lt;bool&gt;
<span class="lineNum">     369 </span>                :            : struct CompileAssert {
<span class="lineNum">     370 </span>                :            : };
<span class="lineNum">     371 </span>                :            : 
<span class="lineNum">     372 </span>                :            : }  // namespace internal
<span class="lineNum">     373 </span>                :            : 
<span class="lineNum">     374 </span>                :            : #undef GOOGLE_COMPILE_ASSERT
<span class="lineNum">     375 </span>                :            : #define GOOGLE_COMPILE_ASSERT(expr, msg) \
<span class="lineNum">     376 </span>                :            :   typedef ::google::protobuf::internal::CompileAssert&lt;(bool(expr))&gt; \
<span class="lineNum">     377 </span>                :            :           msg[bool(expr) ? 1 : -1]
<span class="lineNum">     378 </span>                :            : 
<span class="lineNum">     379 </span>                :            : 
<span class="lineNum">     380 </span>                :            : // Implementation details of COMPILE_ASSERT:
<span class="lineNum">     381 </span>                :            : //
<span class="lineNum">     382 </span>                :            : // - COMPILE_ASSERT works by defining an array type that has -1
<span class="lineNum">     383 </span>                :            : //   elements (and thus is invalid) when the expression is false.
<span class="lineNum">     384 </span>                :            : //
<span class="lineNum">     385 </span>                :            : // - The simpler definition
<span class="lineNum">     386 </span>                :            : //
<span class="lineNum">     387 </span>                :            : //     #define COMPILE_ASSERT(expr, msg) typedef char msg[(expr) ? 1 : -1]
<span class="lineNum">     388 </span>                :            : //
<span class="lineNum">     389 </span>                :            : //   does not work, as gcc supports variable-length arrays whose sizes
<span class="lineNum">     390 </span>                :            : //   are determined at run-time (this is gcc's extension and not part
<span class="lineNum">     391 </span>                :            : //   of the C++ standard).  As a result, gcc fails to reject the
<span class="lineNum">     392 </span>                :            : //   following code with the simple definition:
<span class="lineNum">     393 </span>                :            : //
<span class="lineNum">     394 </span>                :            : //     int foo;
<span class="lineNum">     395 </span>                :            : //     COMPILE_ASSERT(foo, msg); // not supposed to compile as foo is
<span class="lineNum">     396 </span>                :            : //                               // not a compile-time constant.
<span class="lineNum">     397 </span>                :            : //
<span class="lineNum">     398 </span>                :            : // - By using the type CompileAssert&lt;(bool(expr))&gt;, we ensures that
<span class="lineNum">     399 </span>                :            : //   expr is a compile-time constant.  (Template arguments must be
<span class="lineNum">     400 </span>                :            : //   determined at compile-time.)
<span class="lineNum">     401 </span>                :            : //
<span class="lineNum">     402 </span>                :            : // - The outter parentheses in CompileAssert&lt;(bool(expr))&gt; are necessary
<span class="lineNum">     403 </span>                :            : //   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written
<span class="lineNum">     404 </span>                :            : //
<span class="lineNum">     405 </span>                :            : //     CompileAssert&lt;bool(expr)&gt;
<span class="lineNum">     406 </span>                :            : //
<span class="lineNum">     407 </span>                :            : //   instead, these compilers will refuse to compile
<span class="lineNum">     408 </span>                :            : //
<span class="lineNum">     409 </span>                :            : //     COMPILE_ASSERT(5 &gt; 0, some_message);
<span class="lineNum">     410 </span>                :            : //
<span class="lineNum">     411 </span>                :            : //   (They seem to think the &quot;&gt;&quot; in &quot;5 &gt; 0&quot; marks the end of the
<span class="lineNum">     412 </span>                :            : //   template argument list.)
<span class="lineNum">     413 </span>                :            : //
<span class="lineNum">     414 </span>                :            : // - The array size is (bool(expr) ? 1 : -1), instead of simply
<span class="lineNum">     415 </span>                :            : //
<span class="lineNum">     416 </span>                :            : //     ((expr) ? 1 : -1).
<span class="lineNum">     417 </span>                :            : //
<span class="lineNum">     418 </span>                :            : //   This is to avoid running into a bug in MS VC 7.1, which
<span class="lineNum">     419 </span>                :            : //   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.
<span class="lineNum">     420 </span>                :            : 
<span class="lineNum">     421 </span>                :            : // ===================================================================
<span class="lineNum">     422 </span>                :            : // from google3/base/scoped_ptr.h
<span class="lineNum">     423 </span>                :            : 
<span class="lineNum">     424 </span>                :            : namespace internal {
<span class="lineNum">     425 </span>                :            : 
<span class="lineNum">     426 </span>                :            : //  This is an implementation designed to match the anticipated future TR2
<span class="lineNum">     427 </span>                :            : //  implementation of the scoped_ptr class, and its closely-related brethren,
<span class="lineNum">     428 </span>                :            : //  scoped_array, scoped_ptr_malloc, and make_scoped_ptr.
<span class="lineNum">     429 </span>                :            : 
<span class="lineNum">     430 </span>                :            : template &lt;class C&gt; class scoped_ptr;
<span class="lineNum">     431 </span>                :            : template &lt;class C&gt; class scoped_array;
<span class="lineNum">     432 </span>                :            : 
<span class="lineNum">     433 </span>                :            : // A scoped_ptr&lt;T&gt; is like a T*, except that the destructor of scoped_ptr&lt;T&gt;
<span class="lineNum">     434 </span>                :            : // automatically deletes the pointer it holds (if any).
<span class="lineNum">     435 </span>                :            : // That is, scoped_ptr&lt;T&gt; owns the T object that it points to.
<span class="lineNum">     436 </span>                :            : // Like a T*, a scoped_ptr&lt;T&gt; may hold either NULL or a pointer to a T object.
<span class="lineNum">     437 </span>                :            : //
<span class="lineNum">     438 </span>                :            : // The size of a scoped_ptr is small:
<span class="lineNum">     439 </span>                :            : // sizeof(scoped_ptr&lt;C&gt;) == sizeof(C*)
<span class="lineNum">     440 </span>                :            : template &lt;class C&gt;
<span class="lineNum">     441 </span>                :            : class scoped_ptr {
<span class="lineNum">     442 </span>                :            :  public:
<span class="lineNum">     443 </span>                :            : 
<span class="lineNum">     444 </span>                :            :   // The element type
<span class="lineNum">     445 </span>                :            :   typedef C element_type;
<span class="lineNum">     446 </span>                :            : 
<span class="lineNum">     447 </span>                :            :   // Constructor.  Defaults to intializing with NULL.
<span class="lineNum">     448 </span>                :            :   // There is no way to create an uninitialized scoped_ptr.
<span class="lineNum">     449 </span>                :            :   // The input parameter must be allocated with new.
<span class="lineNum">     450 </span>                :            :   explicit scoped_ptr(C* p = NULL) : ptr_(p) { }
<span class="lineNum">     451 </span>                :            : 
<span class="lineNum">     452 </span>                :            :   // Destructor.  If there is a C object, delete it.
<span class="lineNum">     453 </span>                :            :   // We don't need to test ptr_ == NULL because C++ does that for us.
<span class="lineNum">     454 </span>                :            :   ~scoped_ptr() {
<span class="lineNum">     455 </span>                :            :     enum { type_must_be_complete = sizeof(C) };
<span class="lineNum">     456 </span>                :            :     delete ptr_;
<span class="lineNum">     457 </span>                :            :   }
<span class="lineNum">     458 </span>                :            : 
<span class="lineNum">     459 </span>                :            :   // Reset.  Deletes the current owned object, if any.
<span class="lineNum">     460 </span>                :            :   // Then takes ownership of a new object, if given.
<span class="lineNum">     461 </span>                :            :   // this-&gt;reset(this-&gt;get()) works.
<span class="lineNum">     462 </span>                :            :   void reset(C* p = NULL) {
<span class="lineNum">     463 </span>                :            :     if (p != ptr_) {
<span class="lineNum">     464 </span>                :            :       enum { type_must_be_complete = sizeof(C) };
<span class="lineNum">     465 </span>                :            :       delete ptr_;
<span class="lineNum">     466 </span>                :            :       ptr_ = p;
<span class="lineNum">     467 </span>                :            :     }
<span class="lineNum">     468 </span>                :            :   }
<span class="lineNum">     469 </span>                :            : 
<span class="lineNum">     470 </span>                :            :   // Accessors to get the owned object.
<span class="lineNum">     471 </span>                :            :   // operator* and operator-&gt; will assert() if there is no current object.
<span class="lineNum">     472 </span>                :            :   C&amp; operator*() const {
<span class="lineNum">     473 </span>                :            :     assert(ptr_ != NULL);
<span class="lineNum">     474 </span>                :            :     return *ptr_;
<span class="lineNum">     475 </span>                :            :   }
<span class="lineNum">     476 </span>                :            :   C* operator-&gt;() const  {
<span class="lineNum">     477 </span>                :            :     assert(ptr_ != NULL);
<span class="lineNum">     478 </span>                :            :     return ptr_;
<span class="lineNum">     479 </span>                :            :   }
<span class="lineNum">     480 </span>                :            :   C* get() const { return ptr_; }
<span class="lineNum">     481 </span>                :            : 
<span class="lineNum">     482 </span>                :            :   // Comparison operators.
<span class="lineNum">     483 </span>                :            :   // These return whether two scoped_ptr refer to the same object, not just to
<span class="lineNum">     484 </span>                :            :   // two different but equal objects.
<span class="lineNum">     485 </span>                :            :   bool operator==(C* p) const { return ptr_ == p; }
<span class="lineNum">     486 </span>                :            :   bool operator!=(C* p) const { return ptr_ != p; }
<span class="lineNum">     487 </span>                :            : 
<span class="lineNum">     488 </span>                :            :   // Swap two scoped pointers.
<span class="lineNum">     489 </span>                :            :   void swap(scoped_ptr&amp; p2) {
<span class="lineNum">     490 </span>                :            :     C* tmp = ptr_;
<span class="lineNum">     491 </span>                :            :     ptr_ = p2.ptr_;
<span class="lineNum">     492 </span>                :            :     p2.ptr_ = tmp;
<span class="lineNum">     493 </span>                :            :   }
<span class="lineNum">     494 </span>                :            : 
<span class="lineNum">     495 </span>                :            :   // Release a pointer.
<span class="lineNum">     496 </span>                :            :   // The return value is the current pointer held by this object.
<span class="lineNum">     497 </span>                :            :   // If this object holds a NULL pointer, the return value is NULL.
<span class="lineNum">     498 </span>                :            :   // After this operation, this object will hold a NULL pointer,
<span class="lineNum">     499 </span>                :            :   // and will not own the object any more.
<span class="lineNum">     500 </span>                :            :   C* release() {
<span class="lineNum">     501 </span>                :            :     C* retVal = ptr_;
<span class="lineNum">     502 </span>                :            :     ptr_ = NULL;
<span class="lineNum">     503 </span>                :            :     return retVal;
<span class="lineNum">     504 </span>                :            :   }
<span class="lineNum">     505 </span>                :            : 
<span class="lineNum">     506 </span>                :            :  private:
<span class="lineNum">     507 </span>                :            :   C* ptr_;
<span class="lineNum">     508 </span>                :            : 
<span class="lineNum">     509 </span>                :            :   // Forbid comparison of scoped_ptr types.  If C2 != C, it totally doesn't
<span class="lineNum">     510 </span>                :            :   // make sense, and if C2 == C, it still doesn't make sense because you should
<span class="lineNum">     511 </span>                :            :   // never have the same object owned by two different scoped_ptrs.
<span class="lineNum">     512 </span>                :            :   template &lt;class C2&gt; bool operator==(scoped_ptr&lt;C2&gt; const&amp; p2) const;
<span class="lineNum">     513 </span>                :            :   template &lt;class C2&gt; bool operator!=(scoped_ptr&lt;C2&gt; const&amp; p2) const;
<span class="lineNum">     514 </span>                :            : 
<span class="lineNum">     515 </span>                :            :   // Disallow evil constructors
<span class="lineNum">     516 </span>                :            :   scoped_ptr(const scoped_ptr&amp;);
<span class="lineNum">     517 </span>                :            :   void operator=(const scoped_ptr&amp;);
<span class="lineNum">     518 </span>                :            : };
<span class="lineNum">     519 </span>                :            : 
<span class="lineNum">     520 </span>                :            : // scoped_array&lt;C&gt; is like scoped_ptr&lt;C&gt;, except that the caller must allocate
<span class="lineNum">     521 </span>                :            : // with new [] and the destructor deletes objects with delete [].
<span class="lineNum">     522 </span>                :            : //
<span class="lineNum">     523 </span>                :            : // As with scoped_ptr&lt;C&gt;, a scoped_array&lt;C&gt; either points to an object
<span class="lineNum">     524 </span>                :            : // or is NULL.  A scoped_array&lt;C&gt; owns the object that it points to.
<span class="lineNum">     525 </span>                :            : //
<span class="lineNum">     526 </span>                :            : // Size: sizeof(scoped_array&lt;C&gt;) == sizeof(C*)
<span class="lineNum">     527 </span>                :            : template &lt;class C&gt;
<span class="lineNum">     528 </span>                :            : class scoped_array {
<span class="lineNum">     529 </span>                :            :  public:
<span class="lineNum">     530 </span>                :            : 
<span class="lineNum">     531 </span>                :            :   // The element type
<span class="lineNum">     532 </span>                :            :   typedef C element_type;
<span class="lineNum">     533 </span>                :            : 
<span class="lineNum">     534 </span>                :            :   // Constructor.  Defaults to intializing with NULL.
<span class="lineNum">     535 </span>                :            :   // There is no way to create an uninitialized scoped_array.
<span class="lineNum">     536 </span>                :            :   // The input parameter must be allocated with new [].
<span class="lineNum">     537 </span>                :            :   explicit scoped_array(C* p = NULL) : array_(p) { }
<span class="lineNum">     538 </span>                :            : 
<span class="lineNum">     539 </span>                :            :   // Destructor.  If there is a C object, delete it.
<span class="lineNum">     540 </span>                :            :   // We don't need to test ptr_ == NULL because C++ does that for us.
<span class="lineNum">     541 </span>                :            :   ~scoped_array() {
<span class="lineNum">     542 </span>                :            :     enum { type_must_be_complete = sizeof(C) };
<span class="lineNum">     543 </span>                :            :     delete[] array_;
<span class="lineNum">     544 </span>                :            :   }
<span class="lineNum">     545 </span>                :            : 
<span class="lineNum">     546 </span>                :            :   // Reset.  Deletes the current owned object, if any.
<span class="lineNum">     547 </span>                :            :   // Then takes ownership of a new object, if given.
<span class="lineNum">     548 </span>                :            :   // this-&gt;reset(this-&gt;get()) works.
<span class="lineNum">     549 </span>                :            :   void reset(C* p = NULL) {
<span class="lineNum">     550 </span>                :            :     if (p != array_) {
<span class="lineNum">     551 </span>                :            :       enum { type_must_be_complete = sizeof(C) };
<span class="lineNum">     552 </span>                :            :       delete[] array_;
<span class="lineNum">     553 </span>                :            :       array_ = p;
<span class="lineNum">     554 </span>                :            :     }
<span class="lineNum">     555 </span>                :            :   }
<span class="lineNum">     556 </span>                :            : 
<span class="lineNum">     557 </span>                :            :   // Get one element of the current object.
<span class="lineNum">     558 </span>                :            :   // Will assert() if there is no current object, or index i is negative.
<span class="lineNum">     559 </span>                :            :   C&amp; operator[](std::ptrdiff_t i) const {
<span class="lineNum">     560 </span>                :            :     assert(i &gt;= 0);
<span class="lineNum">     561 </span>                :            :     assert(array_ != NULL);
<span class="lineNum">     562 </span>                :            :     return array_[i];
<span class="lineNum">     563 </span>                :            :   }
<span class="lineNum">     564 </span>                :            : 
<span class="lineNum">     565 </span>                :            :   // Get a pointer to the zeroth element of the current object.
<span class="lineNum">     566 </span>                :            :   // If there is no current object, return NULL.
<span class="lineNum">     567 </span>                :            :   C* get() const {
<span class="lineNum">     568 </span>                :            :     return array_;
<span class="lineNum">     569 </span>                :            :   }
<span class="lineNum">     570 </span>                :            : 
<span class="lineNum">     571 </span>                :            :   // Comparison operators.
<span class="lineNum">     572 </span>                :            :   // These return whether two scoped_array refer to the same object, not just to
<span class="lineNum">     573 </span>                :            :   // two different but equal objects.
<span class="lineNum">     574 </span>                :            :   bool operator==(C* p) const { return array_ == p; }
<span class="lineNum">     575 </span>                :            :   bool operator!=(C* p) const { return array_ != p; }
<span class="lineNum">     576 </span>                :            : 
<span class="lineNum">     577 </span>                :            :   // Swap two scoped arrays.
<span class="lineNum">     578 </span>                :            :   void swap(scoped_array&amp; p2) {
<span class="lineNum">     579 </span>                :            :     C* tmp = array_;
<span class="lineNum">     580 </span>                :            :     array_ = p2.array_;
<span class="lineNum">     581 </span>                :            :     p2.array_ = tmp;
<span class="lineNum">     582 </span>                :            :   }
<span class="lineNum">     583 </span>                :            : 
<span class="lineNum">     584 </span>                :            :   // Release an array.
<span class="lineNum">     585 </span>                :            :   // The return value is the current pointer held by this object.
<span class="lineNum">     586 </span>                :            :   // If this object holds a NULL pointer, the return value is NULL.
<span class="lineNum">     587 </span>                :            :   // After this operation, this object will hold a NULL pointer,
<span class="lineNum">     588 </span>                :            :   // and will not own the object any more.
<span class="lineNum">     589 </span>                :            :   C* release() {
<span class="lineNum">     590 </span>                :            :     C* retVal = array_;
<span class="lineNum">     591 </span>                :            :     array_ = NULL;
<span class="lineNum">     592 </span>                :            :     return retVal;
<span class="lineNum">     593 </span>                :            :   }
<span class="lineNum">     594 </span>                :            : 
<span class="lineNum">     595 </span>                :            :  private:
<span class="lineNum">     596 </span>                :            :   C* array_;
<span class="lineNum">     597 </span>                :            : 
<span class="lineNum">     598 </span>                :            :   // Forbid comparison of different scoped_array types.
<span class="lineNum">     599 </span>                :            :   template &lt;class C2&gt; bool operator==(scoped_array&lt;C2&gt; const&amp; p2) const;
<span class="lineNum">     600 </span>                :            :   template &lt;class C2&gt; bool operator!=(scoped_array&lt;C2&gt; const&amp; p2) const;
<span class="lineNum">     601 </span>                :            : 
<span class="lineNum">     602 </span>                :            :   // Disallow evil constructors
<span class="lineNum">     603 </span>                :            :   scoped_array(const scoped_array&amp;);
<span class="lineNum">     604 </span>                :            :   void operator=(const scoped_array&amp;);
<span class="lineNum">     605 </span>                :            : };
<span class="lineNum">     606 </span>                :            : 
<span class="lineNum">     607 </span>                :            : }  // namespace internal
<span class="lineNum">     608 </span>                :            : 
<span class="lineNum">     609 </span>                :            : // We made these internal so that they would show up as such in the docs,
<span class="lineNum">     610 </span>                :            : // but we don't want to stick &quot;internal::&quot; in front of them everywhere.
<span class="lineNum">     611 </span>                :            : using internal::scoped_ptr;
<span class="lineNum">     612 </span>                :            : using internal::scoped_array;
<span class="lineNum">     613 </span>                :            : 
<span class="lineNum">     614 </span>                :            : // ===================================================================
<span class="lineNum">     615 </span>                :            : // emulates google3/base/logging.h
<span class="lineNum">     616 </span>                :            : 
<span class="lineNum">     617 </span>                :            : enum LogLevel {
<span class="lineNum">     618 </span>                :            :   LOGLEVEL_INFO,     // Informational.  This is never actually used by
<span class="lineNum">     619 </span>                :            :                      // libprotobuf.
<span class="lineNum">     620 </span>                :            :   LOGLEVEL_WARNING,  // Warns about issues that, although not technically a
<span class="lineNum">     621 </span>                :            :                      // problem now, could cause problems in the future.  For
<span class="lineNum">     622 </span>                :            :                      // example, a // warning will be printed when parsing a
<span class="lineNum">     623 </span>                :            :                      // message that is near the message size limit.
<span class="lineNum">     624 </span>                :            :   LOGLEVEL_ERROR,    // An error occurred which should never happen during
<span class="lineNum">     625 </span>                :            :                      // normal use.
<span class="lineNum">     626 </span>                :            :   LOGLEVEL_FATAL,    // An error occurred from which the library cannot
<span class="lineNum">     627 </span>                :            :                      // recover.  This usually indicates a programming error
<span class="lineNum">     628 </span>                :            :                      // in the code which calls the library, especially when
<span class="lineNum">     629 </span>                :            :                      // compiled in debug mode.
<span class="lineNum">     630 </span>                :            : 
<span class="lineNum">     631 </span>                :            : #ifdef NDEBUG
<span class="lineNum">     632 </span>                :            :   LOGLEVEL_DFATAL = LOGLEVEL_ERROR
<span class="lineNum">     633 </span>                :            : #else
<span class="lineNum">     634 </span>                :            :   LOGLEVEL_DFATAL = LOGLEVEL_FATAL
<span class="lineNum">     635 </span>                :            : #endif
<span class="lineNum">     636 </span>                :            : };
<span class="lineNum">     637 </span>                :            : 
<span class="lineNum">     638 </span>                :            : namespace internal {
<span class="lineNum">     639 </span>                :            : 
<span class="lineNum">     640 </span>                :            : class LogFinisher;
<span class="lineNum">     641 </span>                :            : 
<span class="lineNum">     642 </span>                :            : class LIBPROTOBUF_EXPORT LogMessage {
<span class="lineNum">     643 </span>                :            :  public:
<span class="lineNum">     644 </span>                :            :   LogMessage(LogLevel level, const char* filename, int line);
<span class="lineNum">     645 </span>                :            :   ~LogMessage();
<span class="lineNum">     646 </span>                :            : 
<span class="lineNum">     647 </span>                :            :   LogMessage&amp; operator&lt;&lt;(const std::string&amp; value);
<span class="lineNum">     648 </span>                :            :   LogMessage&amp; operator&lt;&lt;(const char* value);
<span class="lineNum">     649 </span>                :            :   LogMessage&amp; operator&lt;&lt;(char value);
<span class="lineNum">     650 </span>                :            :   LogMessage&amp; operator&lt;&lt;(int value);
<span class="lineNum">     651 </span>                :            :   LogMessage&amp; operator&lt;&lt;(uint value);
<span class="lineNum">     652 </span>                :            :   LogMessage&amp; operator&lt;&lt;(long value);
<span class="lineNum">     653 </span>                :            :   LogMessage&amp; operator&lt;&lt;(unsigned long value);
<span class="lineNum">     654 </span>                :            :   LogMessage&amp; operator&lt;&lt;(double value);
<span class="lineNum">     655 </span>                :            : 
<span class="lineNum">     656 </span>                :            :  private:
<span class="lineNum">     657 </span>                :            :   friend class LogFinisher;
<span class="lineNum">     658 </span>                :            :   void Finish();
<span class="lineNum">     659 </span>                :            : 
<span class="lineNum">     660 </span>                :            :   LogLevel level_;
<span class="lineNum">     661 </span>                :            :   const char* filename_;
<span class="lineNum">     662 </span>                :            :   int line_;
<span class="lineNum">     663 </span>                :            :   std::string message_;
<span class="lineNum">     664 </span>                :            : };
<span class="lineNum">     665 </span>                :            : 
<span class="lineNum">     666 </span>                :            : // Used to make the entire &quot;LOG(BLAH) &lt;&lt; etc.&quot; expression have a void return
<span class="lineNum">     667 </span>                :            : // type and print a newline after each message.
<span class="lineNum">     668 </span>                :            : class LIBPROTOBUF_EXPORT LogFinisher {
<span class="lineNum">     669 </span>                :            :  public:
<span class="lineNum">     670 </span>                :            :   void operator=(LogMessage&amp; other);
<span class="lineNum">     671 </span>                :            : };
<span class="lineNum">     672 </span>                :            : 
<span class="lineNum">     673 </span>                :            : }  // namespace internal
<span class="lineNum">     674 </span>                :            : 
<span class="lineNum">     675 </span>                :            : // Undef everything in case we're being mixed with some other Google library
<span class="lineNum">     676 </span>                :            : // which already defined them itself.  Presumably all Google libraries will
<span class="lineNum">     677 </span>                :            : // support the same syntax for these so it should not be a big deal if they
<span class="lineNum">     678 </span>                :            : // end up using our definitions instead.
<span class="lineNum">     679 </span>                :            : #undef GOOGLE_LOG
<span class="lineNum">     680 </span>                :            : #undef GOOGLE_LOG_IF
<span class="lineNum">     681 </span>                :            : 
<span class="lineNum">     682 </span>                :            : #undef GOOGLE_CHECK
<span class="lineNum">     683 </span>                :            : #undef GOOGLE_CHECK_EQ
<span class="lineNum">     684 </span>                :            : #undef GOOGLE_CHECK_NE
<span class="lineNum">     685 </span>                :            : #undef GOOGLE_CHECK_LT
<span class="lineNum">     686 </span>                :            : #undef GOOGLE_CHECK_LE
<span class="lineNum">     687 </span>                :            : #undef GOOGLE_CHECK_GT
<span class="lineNum">     688 </span>                :            : #undef GOOGLE_CHECK_GE
<span class="lineNum">     689 </span>                :            : 
<span class="lineNum">     690 </span>                :            : #undef GOOGLE_DLOG
<span class="lineNum">     691 </span>                :            : #undef GOOGLE_DCHECK
<span class="lineNum">     692 </span>                :            : #undef GOOGLE_DCHECK_EQ
<span class="lineNum">     693 </span>                :            : #undef GOOGLE_DCHECK_NE
<span class="lineNum">     694 </span>                :            : #undef GOOGLE_DCHECK_LT
<span class="lineNum">     695 </span>                :            : #undef GOOGLE_DCHECK_LE
<span class="lineNum">     696 </span>                :            : #undef GOOGLE_DCHECK_GT
<span class="lineNum">     697 </span>                :            : #undef GOOGLE_DCHECK_GE
<span class="lineNum">     698 </span>                :            : 
<span class="lineNum">     699 </span>                :            : #define GOOGLE_LOG(LEVEL)                                                 \
<span class="lineNum">     700 </span>                :            :   ::google::protobuf::internal::LogFinisher() =                           \
<span class="lineNum">     701 </span>                :            :     ::google::protobuf::internal::LogMessage(                             \
<span class="lineNum">     702 </span>                :            :       ::google::protobuf::LOGLEVEL_##LEVEL, __FILE__, __LINE__)
<span class="lineNum">     703 </span>                :            : #define GOOGLE_LOG_IF(LEVEL, CONDITION) \
<span class="lineNum">     704 </span>                :            :   !(CONDITION) ? (void)0 : GOOGLE_LOG(LEVEL)
<span class="lineNum">     705 </span>                :            : 
<span class="lineNum">     706 </span>                :            : #define GOOGLE_CHECK(EXPRESSION) \
<span class="lineNum">     707 </span>                :            :   GOOGLE_LOG_IF(FATAL, !(EXPRESSION)) &lt;&lt; &quot;CHECK failed: &quot; #EXPRESSION &quot;: &quot;
<span class="lineNum">     708 </span>                :            : #define GOOGLE_CHECK_EQ(A, B) GOOGLE_CHECK((A) == (B))
<span class="lineNum">     709 </span>                :            : #define GOOGLE_CHECK_NE(A, B) GOOGLE_CHECK((A) != (B))
<span class="lineNum">     710 </span>                :            : #define GOOGLE_CHECK_LT(A, B) GOOGLE_CHECK((A) &lt;  (B))
<span class="lineNum">     711 </span>                :            : #define GOOGLE_CHECK_LE(A, B) GOOGLE_CHECK((A) &lt;= (B))
<span class="lineNum">     712 </span>                :            : #define GOOGLE_CHECK_GT(A, B) GOOGLE_CHECK((A) &gt;  (B))
<span class="lineNum">     713 </span>                :            : #define GOOGLE_CHECK_GE(A, B) GOOGLE_CHECK((A) &gt;= (B))
<span class="lineNum">     714 </span>                :            : 
<span class="lineNum">     715 </span>                :            : #ifdef NDEBUG
<span class="lineNum">     716 </span>                :            : 
<span class="lineNum">     717 </span>                :            : #define GOOGLE_DLOG GOOGLE_LOG_IF(INFO, false)
<span class="lineNum">     718 </span>                :            : 
<span class="lineNum">     719 </span>                :            : #define GOOGLE_DCHECK(EXPRESSION) while(false) GOOGLE_CHECK(EXPRESSION)
<span class="lineNum">     720 </span>                :            : #define GOOGLE_DCHECK_EQ(A, B) GOOGLE_DCHECK((A) == (B))
<span class="lineNum">     721 </span>                :            : #define GOOGLE_DCHECK_NE(A, B) GOOGLE_DCHECK((A) != (B))
<span class="lineNum">     722 </span>                :            : #define GOOGLE_DCHECK_LT(A, B) GOOGLE_DCHECK((A) &lt;  (B))
<span class="lineNum">     723 </span>                :            : #define GOOGLE_DCHECK_LE(A, B) GOOGLE_DCHECK((A) &lt;= (B))
<span class="lineNum">     724 </span>                :            : #define GOOGLE_DCHECK_GT(A, B) GOOGLE_DCHECK((A) &gt;  (B))
<span class="lineNum">     725 </span>                :            : #define GOOGLE_DCHECK_GE(A, B) GOOGLE_DCHECK((A) &gt;= (B))
<span class="lineNum">     726 </span>                :            : 
<span class="lineNum">     727 </span>                :            : #else  // NDEBUG
<span class="lineNum">     728 </span>                :            : 
<span class="lineNum">     729 </span>                :            : #define GOOGLE_DLOG GOOGLE_LOG
<span class="lineNum">     730 </span>                :            : 
<span class="lineNum">     731 </span>                :            : #define GOOGLE_DCHECK    GOOGLE_CHECK
<span class="lineNum">     732 </span>                :            : #define GOOGLE_DCHECK_EQ GOOGLE_CHECK_EQ
<span class="lineNum">     733 </span>                :            : #define GOOGLE_DCHECK_NE GOOGLE_CHECK_NE
<span class="lineNum">     734 </span>                :            : #define GOOGLE_DCHECK_LT GOOGLE_CHECK_LT
<span class="lineNum">     735 </span>                :            : #define GOOGLE_DCHECK_LE GOOGLE_CHECK_LE
<span class="lineNum">     736 </span>                :            : #define GOOGLE_DCHECK_GT GOOGLE_CHECK_GT
<span class="lineNum">     737 </span>                :            : #define GOOGLE_DCHECK_GE GOOGLE_CHECK_GE
<span class="lineNum">     738 </span>                :            : 
<span class="lineNum">     739 </span>                :            : #endif  // !NDEBUG
<span class="lineNum">     740 </span>                :            : 
<span class="lineNum">     741 </span>                :            : typedef void LogHandler(LogLevel level, const char* filename, int line,
<span class="lineNum">     742 </span>                :            :                         const std::string&amp; message);
<span class="lineNum">     743 </span>                :            : 
<span class="lineNum">     744 </span>                :            : // The protobuf library sometimes writes warning and error messages to
<span class="lineNum">     745 </span>                :            : // stderr.  These messages are primarily useful for developers, but may
<span class="lineNum">     746 </span>                :            : // also help end users figure out a problem.  If you would prefer that
<span class="lineNum">     747 </span>                :            : // these messages be sent somewhere other than stderr, call SetLogHandler()
<span class="lineNum">     748 </span>                :            : // to set your own handler.  This returns the old handler.  Set the handler
<span class="lineNum">     749 </span>                :            : // to NULL to ignore log messages (but see also LogSilencer, below).
<span class="lineNum">     750 </span>                :            : //
<span class="lineNum">     751 </span>                :            : // Obviously, SetLogHandler is not thread-safe.  You should only call it
<span class="lineNum">     752 </span>                :            : // at initialization time, and probably not from library code.  If you
<span class="lineNum">     753 </span>                :            : // simply want to suppress log messages temporarily (e.g. because you
<span class="lineNum">     754 </span>                :            : // have some code that tends to trigger them frequently and you know
<span class="lineNum">     755 </span>                :            : // the warnings are not important to you), use the LogSilencer class
<span class="lineNum">     756 </span>                :            : // below.
<span class="lineNum">     757 </span>                :            : LIBPROTOBUF_EXPORT LogHandler* SetLogHandler(LogHandler* new_func);
<span class="lineNum">     758 </span>                :            : 
<span class="lineNum">     759 </span>                :            : // Create a LogSilencer if you want to temporarily suppress all log
<span class="lineNum">     760 </span>                :            : // messages.  As long as any LogSilencer objects exist, non-fatal
<span class="lineNum">     761 </span>                :            : // log messages will be discarded (the current LogHandler will *not*
<span class="lineNum">     762 </span>                :            : // be called).  Constructing a LogSilencer is thread-safe.  You may
<span class="lineNum">     763 </span>                :            : // accidentally suppress log messages occurring in another thread, but
<span class="lineNum">     764 </span>                :            : // since messages are generally for debugging purposes only, this isn't
<span class="lineNum">     765 </span>                :            : // a big deal.  If you want to intercept log messages, use SetLogHandler().
<span class="lineNum">     766 </span>                :            : class LIBPROTOBUF_EXPORT LogSilencer {
<span class="lineNum">     767 </span>                :            :  public:
<span class="lineNum">     768 </span>                :            :   LogSilencer();
<span class="lineNum">     769 </span>                :            :   ~LogSilencer();
<span class="lineNum">     770 </span>                :            : };
<span class="lineNum">     771 </span>                :            : 
<span class="lineNum">     772 </span>                :            : // ===================================================================
<span class="lineNum">     773 </span>                :            : // emulates google3/base/callback.h
<span class="lineNum">     774 </span>                :            : 
<span class="lineNum">     775 </span>                :            : // Abstract interface for a callback.  When calling an RPC, you must provide
<span class="lineNum">     776 </span>                :            : // a Closure to call when the procedure completes.  See the Service interface
<span class="lineNum">     777 </span>                :            : // in service.h.
<span class="lineNum">     778 </span>                :            : //
<span class="lineNum">     779 </span>                :            : // To automatically construct a Closure which calls a particular function or
<span class="lineNum">     780 </span>                :            : // method with a particular set of parameters, use the NewCallback() function.
<span class="lineNum">     781 </span>                :            : // Example:
<span class="lineNum">     782 </span>                :            : //   void FooDone(const FooResponse* response) {
<span class="lineNum">     783 </span>                :            : //     ...
<span class="lineNum">     784 </span>                :            : //   }
<span class="lineNum">     785 </span>                :            : //
<span class="lineNum">     786 </span>                :            : //   void CallFoo() {
<span class="lineNum">     787 </span>                :            : //     ...
<span class="lineNum">     788 </span>                :            : //     // When done, call FooDone() and pass it a pointer to the response.
<span class="lineNum">     789 </span>                :            : //     Closure* callback = NewCallback(&amp;FooDone, response);
<span class="lineNum">     790 </span>                :            : //     // Make the call.
<span class="lineNum">     791 </span>                :            : //     service-&gt;Foo(controller, request, response, callback);
<span class="lineNum">     792 </span>                :            : //   }
<span class="lineNum">     793 </span>                :            : //
<span class="lineNum">     794 </span>                :            : // Example that calls a method:
<span class="lineNum">     795 </span>                :            : //   class Handler {
<span class="lineNum">     796 </span>                :            : //    public:
<span class="lineNum">     797 </span>                :            : //     ...
<span class="lineNum">     798 </span>                :            : //
<span class="lineNum">     799 </span>                :            : //     void FooDone(const FooResponse* response) {
<span class="lineNum">     800 </span>                :            : //       ...
<span class="lineNum">     801 </span>                :            : //     }
<span class="lineNum">     802 </span>                :            : //
<span class="lineNum">     803 </span>                :            : //     void CallFoo() {
<span class="lineNum">     804 </span>                :            : //       ...
<span class="lineNum">     805 </span>                :            : //       // When done, call FooDone() and pass it a pointer to the response.
<span class="lineNum">     806 </span>                :            : //       Closure* callback = NewCallback(this, &amp;Handler::FooDone, response);
<span class="lineNum">     807 </span>                :            : //       // Make the call.
<span class="lineNum">     808 </span>                :            : //       service-&gt;Foo(controller, request, response, callback);
<span class="lineNum">     809 </span>                :            : //     }
<span class="lineNum">     810 </span>                :            : //   };
<span class="lineNum">     811 </span>                :            : //
<span class="lineNum">     812 </span>                :            : // Currently NewCallback() supports binding zero, one, or two arguments.
<span class="lineNum">     813 </span>                :            : //
<span class="lineNum">     814 </span>                :            : // Callbacks created with NewCallback() automatically delete themselves when
<span class="lineNum">     815 </span>                :            : // executed.  They should be used when a callback is to be called exactly
<span class="lineNum">     816 </span>                :            : // once (usually the case with RPC callbacks).  If a callback may be called
<span class="lineNum">     817 </span>                :            : // a different number of times (including zero), create it with
<span class="lineNum">     818 </span>                :            : // NewPermanentCallback() instead.  You are then responsible for deleting the
<span class="lineNum">     819 </span>                :            : // callback (using the &quot;delete&quot; keyword as normal).
<span class="lineNum">     820 </span>                :            : //
<span class="lineNum">     821 </span>                :            : // Note that NewCallback() is a bit touchy regarding argument types.  Generally,
<span class="lineNum">     822 </span>                :            : // the values you provide for the parameter bindings must exactly match the
<span class="lineNum">     823 </span>                :            : // types accepted by the callback function.  For example:
<span class="lineNum">     824 </span>                :            : //   void Foo(string s);
<span class="lineNum">     825 </span>                :            : //   NewCallback(&amp;Foo, &quot;foo&quot;);          // WON'T WORK:  const char* != string
<span class="lineNum">     826 </span>                :            : //   NewCallback(&amp;Foo, string(&quot;foo&quot;));  // WORKS
<span class="lineNum">     827 </span>                :            : // Also note that the arguments cannot be references:
<span class="lineNum">     828 </span>                :            : //   void Foo(const string&amp; s);
<span class="lineNum">     829 </span>                :            : //   string my_str;
<span class="lineNum">     830 </span>                :            : //   NewCallback(&amp;Foo, my_str);  // WON'T WORK:  Can't use referecnes.
<span class="lineNum">     831 </span>                :            : // However, correctly-typed pointers will work just fine.
<span class="lineNum">     832 </span>                :            : class LIBPROTOBUF_EXPORT Closure {
<span class="lineNum">     833 </span>                :            :  public:
<span class="lineNum">     834 </span>                :            :   Closure() {}
<span class="lineNum">     835 </span>                :            :   virtual ~Closure();
<span class="lineNum">     836 </span>                :            : 
<span class="lineNum">     837 </span>                :            :   virtual void Run() = 0;
<span class="lineNum">     838 </span>                :            : 
<span class="lineNum">     839 </span>                :            :  private:
<span class="lineNum">     840 </span>                :            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Closure);
<span class="lineNum">     841 </span>                :            : };
<span class="lineNum">     842 </span>                :            : 
<span class="lineNum">     843 </span>                :            : namespace internal {
<span class="lineNum">     844 </span>                :            : 
<span class="lineNum">     845 </span>                :            : class LIBPROTOBUF_EXPORT FunctionClosure0 : public Closure {
<span class="lineNum">     846 </span>                :            :  public:
<span class="lineNum">     847 </span>                :            :   typedef void (*FunctionType)();
<span class="lineNum">     848 </span>                :            : 
<span class="lineNum">     849 </span>                :            :   FunctionClosure0(FunctionType function, bool self_deleting)
<span class="lineNum">     850 </span>                :            :     : function_(function), self_deleting_(self_deleting) {}
<a name="851"><span class="lineNum">     851 </span>                :            :   ~FunctionClosure0();</a>
<span class="lineNum">     852 </span>                :            : 
<span class="lineNum">     853 </span>                :<span class="lineNoCov">          0 :   void Run() {</span>
<span class="lineNum">     854 </span>                :<span class="lineNoCov">          0 :     bool needs_delete = self_deleting_;  // read in case callback deletes</span>
<span class="lineNum">     855 </span>                :<span class="lineNoCov">          0 :     function_();</span>
<span class="lineNum">     856 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :     if (needs_delete) delete this;</span>
<span class="lineNum">     857 </span>                :<span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     858 </span>                :            : 
<span class="lineNum">     859 </span>                :            :  private:
<span class="lineNum">     860 </span>                :            :   FunctionType function_;
<span class="lineNum">     861 </span>                :            :   bool self_deleting_;
<span class="lineNum">     862 </span>                :            : };
<span class="lineNum">     863 </span>                :            : 
<span class="lineNum">     864 </span>                :            : template &lt;typename Class&gt;
<span class="lineNum">     865 </span>                :            : class MethodClosure0 : public Closure {
<span class="lineNum">     866 </span>                :            :  public:
<span class="lineNum">     867 </span>                :            :   typedef void (Class::*MethodType)();
<span class="lineNum">     868 </span>                :            : 
<span class="lineNum">     869 </span>                :            :   MethodClosure0(Class* object, MethodType method, bool self_deleting)
<span class="lineNum">     870 </span>                :            :     : object_(object), method_(method), self_deleting_(self_deleting) {}
<span class="lineNum">     871 </span>                :            :   ~MethodClosure0() {}
<span class="lineNum">     872 </span>                :            : 
<span class="lineNum">     873 </span>                :            :   void Run() {
<span class="lineNum">     874 </span>                :            :     bool needs_delete = self_deleting_;  // read in case callback deletes
<span class="lineNum">     875 </span>                :            :     (object_-&gt;*method_)();
<span class="lineNum">     876 </span>                :            :     if (needs_delete) delete this;
<span class="lineNum">     877 </span>                :            :   }
<span class="lineNum">     878 </span>                :            : 
<span class="lineNum">     879 </span>                :            :  private:
<span class="lineNum">     880 </span>                :            :   Class* object_;
<span class="lineNum">     881 </span>                :            :   MethodType method_;
<span class="lineNum">     882 </span>                :            :   bool self_deleting_;
<span class="lineNum">     883 </span>                :            : };
<span class="lineNum">     884 </span>                :            : 
<span class="lineNum">     885 </span>                :            : template &lt;typename Arg1&gt;
<span class="lineNum">     886 </span>                :            : class FunctionClosure1 : public Closure {
<span class="lineNum">     887 </span>                :            :  public:
<span class="lineNum">     888 </span>                :            :   typedef void (*FunctionType)(Arg1 arg1);
<span class="lineNum">     889 </span>                :            : 
<span class="lineNum">     890 </span>                :            :   FunctionClosure1(FunctionType function, bool self_deleting,
<span class="lineNum">     891 </span>                :            :                    Arg1 arg1)
<span class="lineNum">     892 </span>                :            :     : function_(function), self_deleting_(self_deleting),
<span class="lineNum">     893 </span>                :            :       arg1_(arg1) {}
<span class="lineNum">     894 </span>                :            :   ~FunctionClosure1() {}
<span class="lineNum">     895 </span>                :            : 
<span class="lineNum">     896 </span>                :            :   void Run() {
<span class="lineNum">     897 </span>                :            :     bool needs_delete = self_deleting_;  // read in case callback deletes
<span class="lineNum">     898 </span>                :            :     function_(arg1_);
<span class="lineNum">     899 </span>                :            :     if (needs_delete) delete this;
<span class="lineNum">     900 </span>                :            :   }
<span class="lineNum">     901 </span>                :            : 
<span class="lineNum">     902 </span>                :            :  private:
<span class="lineNum">     903 </span>                :            :   FunctionType function_;
<span class="lineNum">     904 </span>                :            :   bool self_deleting_;
<span class="lineNum">     905 </span>                :            :   Arg1 arg1_;
<span class="lineNum">     906 </span>                :            : };
<span class="lineNum">     907 </span>                :            : 
<span class="lineNum">     908 </span>                :            : template &lt;typename Class, typename Arg1&gt;
<span class="lineNum">     909 </span>                :            : class MethodClosure1 : public Closure {
<span class="lineNum">     910 </span>                :            :  public:
<span class="lineNum">     911 </span>                :            :   typedef void (Class::*MethodType)(Arg1 arg1);
<span class="lineNum">     912 </span>                :            : 
<span class="lineNum">     913 </span>                :            :   MethodClosure1(Class* object, MethodType method, bool self_deleting,
<span class="lineNum">     914 </span>                :            :                  Arg1 arg1)
<span class="lineNum">     915 </span>                :            :     : object_(object), method_(method), self_deleting_(self_deleting),
<span class="lineNum">     916 </span>                :            :       arg1_(arg1) {}
<span class="lineNum">     917 </span>                :            :   ~MethodClosure1() {}
<span class="lineNum">     918 </span>                :            : 
<span class="lineNum">     919 </span>                :            :   void Run() {
<span class="lineNum">     920 </span>                :            :     bool needs_delete = self_deleting_;  // read in case callback deletes
<span class="lineNum">     921 </span>                :            :     (object_-&gt;*method_)(arg1_);
<span class="lineNum">     922 </span>                :            :     if (needs_delete) delete this;
<span class="lineNum">     923 </span>                :            :   }
<span class="lineNum">     924 </span>                :            : 
<span class="lineNum">     925 </span>                :            :  private:
<span class="lineNum">     926 </span>                :            :   Class* object_;
<span class="lineNum">     927 </span>                :            :   MethodType method_;
<span class="lineNum">     928 </span>                :            :   bool self_deleting_;
<span class="lineNum">     929 </span>                :            :   Arg1 arg1_;
<span class="lineNum">     930 </span>                :            : };
<span class="lineNum">     931 </span>                :            : 
<span class="lineNum">     932 </span>                :            : template &lt;typename Arg1, typename Arg2&gt;
<span class="lineNum">     933 </span>                :            : class FunctionClosure2 : public Closure {
<span class="lineNum">     934 </span>                :            :  public:
<span class="lineNum">     935 </span>                :            :   typedef void (*FunctionType)(Arg1 arg1, Arg2 arg2);
<span class="lineNum">     936 </span>                :            : 
<span class="lineNum">     937 </span>                :            :   FunctionClosure2(FunctionType function, bool self_deleting,
<span class="lineNum">     938 </span>                :            :                    Arg1 arg1, Arg2 arg2)
<span class="lineNum">     939 </span>                :            :     : function_(function), self_deleting_(self_deleting),
<span class="lineNum">     940 </span>                :            :       arg1_(arg1), arg2_(arg2) {}
<span class="lineNum">     941 </span>                :            :   ~FunctionClosure2() {}
<span class="lineNum">     942 </span>                :            : 
<span class="lineNum">     943 </span>                :            :   void Run() {
<span class="lineNum">     944 </span>                :            :     bool needs_delete = self_deleting_;  // read in case callback deletes
<span class="lineNum">     945 </span>                :            :     function_(arg1_, arg2_);
<span class="lineNum">     946 </span>                :            :     if (needs_delete) delete this;
<span class="lineNum">     947 </span>                :            :   }
<span class="lineNum">     948 </span>                :            : 
<span class="lineNum">     949 </span>                :            :  private:
<span class="lineNum">     950 </span>                :            :   FunctionType function_;
<span class="lineNum">     951 </span>                :            :   bool self_deleting_;
<span class="lineNum">     952 </span>                :            :   Arg1 arg1_;
<span class="lineNum">     953 </span>                :            :   Arg2 arg2_;
<span class="lineNum">     954 </span>                :            : };
<span class="lineNum">     955 </span>                :            : 
<span class="lineNum">     956 </span>                :            : template &lt;typename Class, typename Arg1, typename Arg2&gt;
<span class="lineNum">     957 </span>                :            : class MethodClosure2 : public Closure {
<span class="lineNum">     958 </span>                :            :  public:
<span class="lineNum">     959 </span>                :            :   typedef void (Class::*MethodType)(Arg1 arg1, Arg2 arg2);
<span class="lineNum">     960 </span>                :            : 
<span class="lineNum">     961 </span>                :            :   MethodClosure2(Class* object, MethodType method, bool self_deleting,
<span class="lineNum">     962 </span>                :            :                  Arg1 arg1, Arg2 arg2)
<span class="lineNum">     963 </span>                :            :     : object_(object), method_(method), self_deleting_(self_deleting),
<span class="lineNum">     964 </span>                :            :       arg1_(arg1), arg2_(arg2) {}
<span class="lineNum">     965 </span>                :            :   ~MethodClosure2() {}
<span class="lineNum">     966 </span>                :            : 
<span class="lineNum">     967 </span>                :            :   void Run() {
<span class="lineNum">     968 </span>                :            :     bool needs_delete = self_deleting_;  // read in case callback deletes
<span class="lineNum">     969 </span>                :            :     (object_-&gt;*method_)(arg1_, arg2_);
<span class="lineNum">     970 </span>                :            :     if (needs_delete) delete this;
<span class="lineNum">     971 </span>                :            :   }
<span class="lineNum">     972 </span>                :            : 
<span class="lineNum">     973 </span>                :            :  private:
<span class="lineNum">     974 </span>                :            :   Class* object_;
<span class="lineNum">     975 </span>                :            :   MethodType method_;
<span class="lineNum">     976 </span>                :            :   bool self_deleting_;
<span class="lineNum">     977 </span>                :            :   Arg1 arg1_;
<span class="lineNum">     978 </span>                :            :   Arg2 arg2_;
<span class="lineNum">     979 </span>                :            : };
<span class="lineNum">     980 </span>                :            : 
<span class="lineNum">     981 </span>                :            : }  // namespace internal
<span class="lineNum">     982 </span>                :            : 
<span class="lineNum">     983 </span>                :            : // See Closure.
<span class="lineNum">     984 </span>                :            : inline Closure* NewCallback(void (*function)()) {
<span class="lineNum">     985 </span>                :            :   return new internal::FunctionClosure0(function, true);
<span class="lineNum">     986 </span>                :            : }
<span class="lineNum">     987 </span>                :            : 
<span class="lineNum">     988 </span>                :            : // See Closure.
<span class="lineNum">     989 </span>                :            : inline Closure* NewPermanentCallback(void (*function)()) {
<span class="lineNum">     990 </span>                :            :   return new internal::FunctionClosure0(function, false);
<span class="lineNum">     991 </span>                :            : }
<span class="lineNum">     992 </span>                :            : 
<span class="lineNum">     993 </span>                :            : // See Closure.
<span class="lineNum">     994 </span>                :            : template &lt;typename Class&gt;
<span class="lineNum">     995 </span>                :            : inline Closure* NewCallback(Class* object, void (Class::*method)()) {
<span class="lineNum">     996 </span>                :            :   return new internal::MethodClosure0&lt;Class&gt;(object, method, true);
<span class="lineNum">     997 </span>                :            : }
<span class="lineNum">     998 </span>                :            : 
<span class="lineNum">     999 </span>                :            : // See Closure.
<span class="lineNum">    1000 </span>                :            : template &lt;typename Class&gt;
<span class="lineNum">    1001 </span>                :            : inline Closure* NewPermanentCallback(Class* object, void (Class::*method)()) {
<span class="lineNum">    1002 </span>                :            :   return new internal::MethodClosure0&lt;Class&gt;(object, method, false);
<span class="lineNum">    1003 </span>                :            : }
<span class="lineNum">    1004 </span>                :            : 
<span class="lineNum">    1005 </span>                :            : // See Closure.
<span class="lineNum">    1006 </span>                :            : template &lt;typename Arg1&gt;
<span class="lineNum">    1007 </span>                :            : inline Closure* NewCallback(void (*function)(Arg1),
<span class="lineNum">    1008 </span>                :            :                             Arg1 arg1) {
<span class="lineNum">    1009 </span>                :            :   return new internal::FunctionClosure1&lt;Arg1&gt;(function, true, arg1);
<span class="lineNum">    1010 </span>                :            : }
<span class="lineNum">    1011 </span>                :            : 
<span class="lineNum">    1012 </span>                :            : // See Closure.
<span class="lineNum">    1013 </span>                :            : template &lt;typename Arg1&gt;
<span class="lineNum">    1014 </span>                :            : inline Closure* NewPermanentCallback(void (*function)(Arg1),
<span class="lineNum">    1015 </span>                :            :                                      Arg1 arg1) {
<span class="lineNum">    1016 </span>                :            :   return new internal::FunctionClosure1&lt;Arg1&gt;(function, false, arg1);
<span class="lineNum">    1017 </span>                :            : }
<span class="lineNum">    1018 </span>                :            : 
<span class="lineNum">    1019 </span>                :            : // See Closure.
<span class="lineNum">    1020 </span>                :            : template &lt;typename Class, typename Arg1&gt;
<span class="lineNum">    1021 </span>                :            : inline Closure* NewCallback(Class* object, void (Class::*method)(Arg1),
<span class="lineNum">    1022 </span>                :            :                             Arg1 arg1) {
<span class="lineNum">    1023 </span>                :            :   return new internal::MethodClosure1&lt;Class, Arg1&gt;(object, method, true, arg1);
<span class="lineNum">    1024 </span>                :            : }
<span class="lineNum">    1025 </span>                :            : 
<span class="lineNum">    1026 </span>                :            : // See Closure.
<span class="lineNum">    1027 </span>                :            : template &lt;typename Class, typename Arg1&gt;
<span class="lineNum">    1028 </span>                :            : inline Closure* NewPermanentCallback(Class* object, void (Class::*method)(Arg1),
<span class="lineNum">    1029 </span>                :            :                                      Arg1 arg1) {
<span class="lineNum">    1030 </span>                :            :   return new internal::MethodClosure1&lt;Class, Arg1&gt;(object, method, false, arg1);
<span class="lineNum">    1031 </span>                :            : }
<span class="lineNum">    1032 </span>                :            : 
<span class="lineNum">    1033 </span>                :            : // See Closure.
<span class="lineNum">    1034 </span>                :            : template &lt;typename Arg1, typename Arg2&gt;
<span class="lineNum">    1035 </span>                :            : inline Closure* NewCallback(void (*function)(Arg1, Arg2),
<span class="lineNum">    1036 </span>                :            :                             Arg1 arg1, Arg2 arg2) {
<span class="lineNum">    1037 </span>                :            :   return new internal::FunctionClosure2&lt;Arg1, Arg2&gt;(
<span class="lineNum">    1038 </span>                :            :     function, true, arg1, arg2);
<span class="lineNum">    1039 </span>                :            : }
<span class="lineNum">    1040 </span>                :            : 
<span class="lineNum">    1041 </span>                :            : // See Closure.
<span class="lineNum">    1042 </span>                :            : template &lt;typename Arg1, typename Arg2&gt;
<span class="lineNum">    1043 </span>                :            : inline Closure* NewPermanentCallback(void (*function)(Arg1, Arg2),
<span class="lineNum">    1044 </span>                :            :                                      Arg1 arg1, Arg2 arg2) {
<span class="lineNum">    1045 </span>                :            :   return new internal::FunctionClosure2&lt;Arg1, Arg2&gt;(
<span class="lineNum">    1046 </span>                :            :     function, false, arg1, arg2);
<span class="lineNum">    1047 </span>                :            : }
<span class="lineNum">    1048 </span>                :            : 
<span class="lineNum">    1049 </span>                :            : // See Closure.
<span class="lineNum">    1050 </span>                :            : template &lt;typename Class, typename Arg1, typename Arg2&gt;
<span class="lineNum">    1051 </span>                :            : inline Closure* NewCallback(Class* object, void (Class::*method)(Arg1, Arg2),
<span class="lineNum">    1052 </span>                :            :                             Arg1 arg1, Arg2 arg2) {
<span class="lineNum">    1053 </span>                :            :   return new internal::MethodClosure2&lt;Class, Arg1, Arg2&gt;(
<span class="lineNum">    1054 </span>                :            :     object, method, true, arg1, arg2);
<span class="lineNum">    1055 </span>                :            : }
<span class="lineNum">    1056 </span>                :            : 
<span class="lineNum">    1057 </span>                :            : // See Closure.
<span class="lineNum">    1058 </span>                :            : template &lt;typename Class, typename Arg1, typename Arg2&gt;
<span class="lineNum">    1059 </span>                :            : inline Closure* NewPermanentCallback(
<span class="lineNum">    1060 </span>                :            :     Class* object, void (Class::*method)(Arg1, Arg2),
<span class="lineNum">    1061 </span>                :            :     Arg1 arg1, Arg2 arg2) {
<span class="lineNum">    1062 </span>                :            :   return new internal::MethodClosure2&lt;Class, Arg1, Arg2&gt;(
<span class="lineNum">    1063 </span>                :            :     object, method, false, arg1, arg2);
<span class="lineNum">    1064 </span>                :            : }
<span class="lineNum">    1065 </span>                :            : 
<span class="lineNum">    1066 </span>                :            : // A function which does nothing.  Useful for creating no-op callbacks, e.g.:
<span class="lineNum">    1067 </span>                :            : //   Closure* nothing = NewCallback(&amp;DoNothing);
<span class="lineNum">    1068 </span>                :            : void LIBPROTOBUF_EXPORT DoNothing();
<span class="lineNum">    1069 </span>                :            : 
<span class="lineNum">    1070 </span>                :            : // ===================================================================
<span class="lineNum">    1071 </span>                :            : // emulates google3/base/mutex.h
<span class="lineNum">    1072 </span>                :            : 
<span class="lineNum">    1073 </span>                :            : namespace internal {
<span class="lineNum">    1074 </span>                :            : 
<span class="lineNum">    1075 </span>                :            : // A Mutex is a non-reentrant (aka non-recursive) mutex.  At most one thread T
<span class="lineNum">    1076 </span>                :            : // may hold a mutex at a given time.  If T attempts to Lock() the same Mutex
<span class="lineNum">    1077 </span>                :            : // while holding it, T will deadlock.
<span class="lineNum">    1078 </span>                :            : class LIBPROTOBUF_EXPORT Mutex {
<span class="lineNum">    1079 </span>                :            :  public:
<span class="lineNum">    1080 </span>                :            :   // Create a Mutex that is not held by anybody.
<span class="lineNum">    1081 </span>                :            :   Mutex();
<span class="lineNum">    1082 </span>                :            : 
<span class="lineNum">    1083 </span>                :            :   // Destructor
<span class="lineNum">    1084 </span>                :            :   ~Mutex();
<span class="lineNum">    1085 </span>                :            : 
<span class="lineNum">    1086 </span>                :            :   // Block if necessary until this Mutex is free, then acquire it exclusively.
<span class="lineNum">    1087 </span>                :            :   void Lock();
<span class="lineNum">    1088 </span>                :            : 
<span class="lineNum">    1089 </span>                :            :   // Release this Mutex.  Caller must hold it exclusively.
<span class="lineNum">    1090 </span>                :            :   void Unlock();
<span class="lineNum">    1091 </span>                :            : 
<span class="lineNum">    1092 </span>                :            :   // Crash if this Mutex is not held exclusively by this thread.
<span class="lineNum">    1093 </span>                :            :   // May fail to crash when it should; will never crash when it should not.
<span class="lineNum">    1094 </span>                :            :   void AssertHeld();
<span class="lineNum">    1095 </span>                :            : 
<span class="lineNum">    1096 </span>                :            :  private:
<span class="lineNum">    1097 </span>                :            :   struct Internal;
<span class="lineNum">    1098 </span>                :            :   Internal* mInternal;
<span class="lineNum">    1099 </span>                :            : 
<span class="lineNum">    1100 </span>                :            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Mutex);
<span class="lineNum">    1101 </span>                :            : };
<span class="lineNum">    1102 </span>                :            : 
<span class="lineNum">    1103 </span>                :            : // MutexLock(mu) acquires mu when constructed and releases it when destroyed.
<span class="lineNum">    1104 </span>                :            : class LIBPROTOBUF_EXPORT MutexLock {
<span class="lineNum">    1105 </span>                :            :  public:
<span class="lineNum">    1106 </span>                :            :   explicit MutexLock(Mutex *mu) : mu_(mu) { this-&gt;mu_-&gt;Lock(); }
<span class="lineNum">    1107 </span>                :            :   ~MutexLock() { this-&gt;mu_-&gt;Unlock(); }
<span class="lineNum">    1108 </span>                :            :  private:
<span class="lineNum">    1109 </span>                :            :   Mutex *const mu_;
<span class="lineNum">    1110 </span>                :            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MutexLock);
<span class="lineNum">    1111 </span>                :            : };
<span class="lineNum">    1112 </span>                :            : 
<span class="lineNum">    1113 </span>                :            : // TODO(kenton):  Implement these?  Hard to implement portably.
<span class="lineNum">    1114 </span>                :            : typedef MutexLock ReaderMutexLock;
<span class="lineNum">    1115 </span>                :            : typedef MutexLock WriterMutexLock;
<span class="lineNum">    1116 </span>                :            : 
<span class="lineNum">    1117 </span>                :            : // MutexLockMaybe is like MutexLock, but is a no-op when mu is NULL.
<span class="lineNum">    1118 </span>                :            : class LIBPROTOBUF_EXPORT MutexLockMaybe {
<span class="lineNum">    1119 </span>                :            :  public:
<span class="lineNum">    1120 </span>                :            :   explicit MutexLockMaybe(Mutex *mu) :
<span class="lineNum">    1121 </span>                :            :     mu_(mu) { if (this-&gt;mu_ != NULL) { this-&gt;mu_-&gt;Lock(); } }
<span class="lineNum">    1122 </span>                :            :   ~MutexLockMaybe() { if (this-&gt;mu_ != NULL) { this-&gt;mu_-&gt;Unlock(); } }
<span class="lineNum">    1123 </span>                :            :  private:
<span class="lineNum">    1124 </span>                :            :   Mutex *const mu_;
<span class="lineNum">    1125 </span>                :            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MutexLockMaybe);
<span class="lineNum">    1126 </span>                :            : };
<span class="lineNum">    1127 </span>                :            : 
<span class="lineNum">    1128 </span>                :            : }  // namespace internal
<span class="lineNum">    1129 </span>                :            : 
<span class="lineNum">    1130 </span>                :            : // We made these internal so that they would show up as such in the docs,
<span class="lineNum">    1131 </span>                :            : // but we don't want to stick &quot;internal::&quot; in front of them everywhere.
<span class="lineNum">    1132 </span>                :            : using internal::Mutex;
<span class="lineNum">    1133 </span>                :            : using internal::MutexLock;
<span class="lineNum">    1134 </span>                :            : using internal::ReaderMutexLock;
<span class="lineNum">    1135 </span>                :            : using internal::WriterMutexLock;
<span class="lineNum">    1136 </span>                :            : using internal::MutexLockMaybe;
<span class="lineNum">    1137 </span>                :            : 
<span class="lineNum">    1138 </span>                :            : // ===================================================================
<span class="lineNum">    1139 </span>                :            : // from google3/base/type_traits.h
<span class="lineNum">    1140 </span>                :            : 
<span class="lineNum">    1141 </span>                :            : namespace internal {
<span class="lineNum">    1142 </span>                :            : 
<span class="lineNum">    1143 </span>                :            : // Specified by TR1 [4.7.4] Pointer modifications.
<span class="lineNum">    1144 </span>                :            : template&lt;typename T&gt; struct remove_pointer { typedef T type; };
<span class="lineNum">    1145 </span>                :            : template&lt;typename T&gt; struct remove_pointer&lt;T*&gt; { typedef T type; };
<span class="lineNum">    1146 </span>                :            : template&lt;typename T&gt; struct remove_pointer&lt;T* const&gt; { typedef T type; };
<span class="lineNum">    1147 </span>                :            : template&lt;typename T&gt; struct remove_pointer&lt;T* volatile&gt; { typedef T type; };
<span class="lineNum">    1148 </span>                :            : template&lt;typename T&gt; struct remove_pointer&lt;T* const volatile&gt; {
<span class="lineNum">    1149 </span>                :            :   typedef T type; };
<span class="lineNum">    1150 </span>                :            : 
<span class="lineNum">    1151 </span>                :            : // ===================================================================
<span class="lineNum">    1152 </span>                :            : 
<span class="lineNum">    1153 </span>                :            : // Checks if the buffer contains structurally-valid UTF-8.  Implemented in
<span class="lineNum">    1154 </span>                :            : // structurally_valid.cc.
<span class="lineNum">    1155 </span>                :            : LIBPROTOBUF_EXPORT bool IsStructurallyValidUTF8(const char* buf, int len);
<span class="lineNum">    1156 </span>                :            : 
<span class="lineNum">    1157 </span>                :            : }  // namespace internal
<span class="lineNum">    1158 </span>                :            : 
<span class="lineNum">    1159 </span>                :            : // ===================================================================
<span class="lineNum">    1160 </span>                :            : // Shutdown support.
<span class="lineNum">    1161 </span>                :            : 
<span class="lineNum">    1162 </span>                :            : // Shut down the entire protocol buffers library, deleting all static-duration
<span class="lineNum">    1163 </span>                :            : // objects allocated by the library or by generated .pb.cc files.
<span class="lineNum">    1164 </span>                :            : //
<span class="lineNum">    1165 </span>                :            : // There are two reasons you might want to call this:
<span class="lineNum">    1166 </span>                :            : // * You use a draconian definition of &quot;memory leak&quot; in which you expect
<span class="lineNum">    1167 </span>                :            : //   every single malloc() to have a corresponding free(), even for objects
<span class="lineNum">    1168 </span>                :            : //   which live until program exit.
<span class="lineNum">    1169 </span>                :            : // * You are writing a dynamically-loaded library which needs to clean up
<span class="lineNum">    1170 </span>                :            : //   after itself when the library is unloaded.
<span class="lineNum">    1171 </span>                :            : //
<span class="lineNum">    1172 </span>                :            : // It is safe to call this multiple times.  However, it is not safe to use
<span class="lineNum">    1173 </span>                :            : // any other part of the protocol buffers library after
<span class="lineNum">    1174 </span>                :            : // ShutdownProtobufLibrary() has been called.
<span class="lineNum">    1175 </span>                :            : LIBPROTOBUF_EXPORT void ShutdownProtobufLibrary();
<span class="lineNum">    1176 </span>                :            : 
<span class="lineNum">    1177 </span>                :            : namespace internal {
<span class="lineNum">    1178 </span>                :            : 
<span class="lineNum">    1179 </span>                :            : // Register a function to be called when ShutdownProtocolBuffers() is called.
<span class="lineNum">    1180 </span>                :            : LIBPROTOBUF_EXPORT void OnShutdown(void (*func)());
<span class="lineNum">    1181 </span>                :            : 
<span class="lineNum">    1182 </span>                :            : }  // namespace internal
<span class="lineNum">    1183 </span>                :            : 
<span class="lineNum">    1184 </span>                :            : #ifdef PROTOBUF_USE_EXCEPTIONS
<span class="lineNum">    1185 </span>                :            : class FatalException : public std::exception {
<span class="lineNum">    1186 </span>                :            :  public:
<span class="lineNum">    1187 </span>                :            :   FatalException(const char* filename, int line, const std::string&amp; message)
<span class="lineNum">    1188 </span>                :            :       : filename_(filename), line_(line), message_(message) {}
<span class="lineNum">    1189 </span>                :            :   virtual ~FatalException() throw();
<span class="lineNum">    1190 </span>                :            : 
<span class="lineNum">    1191 </span>                :            :   virtual const char* what() const throw();
<span class="lineNum">    1192 </span>                :            : 
<span class="lineNum">    1193 </span>                :            :   const char* filename() const { return filename_; }
<span class="lineNum">    1194 </span>                :            :   int line() const { return line_; }
<span class="lineNum">    1195 </span>                :            :   const std::string&amp; message() const { return message_; }
<span class="lineNum">    1196 </span>                :            : 
<span class="lineNum">    1197 </span>                :            :  private:
<span class="lineNum">    1198 </span>                :            :   const char* filename_;
<span class="lineNum">    1199 </span>                :            :   const int line_;
<span class="lineNum">    1200 </span>                :            :   const std::string message_;
<span class="lineNum">    1201 </span>                :            : };
<span class="lineNum">    1202 </span>                :            : #endif
<span class="lineNum">    1203 </span>                :            : 
<span class="lineNum">    1204 </span>                :            : // This is at the end of the file instead of the beginning to work around a bug
<span class="lineNum">    1205 </span>                :            : // in some versions of MSVC.
<span class="lineNum">    1206 </span>                :            : using namespace std;  // Don't do this at home, kids.
<span class="lineNum">    1207 </span>                :            : 
<span class="lineNum">    1208 </span>                :            : }  // namespace protobuf
<span class="lineNum">    1209 </span>                :            : }  // namespace google
<span class="lineNum">    1210 </span>                :            : 
<span class="lineNum">    1211 </span>                :            : #endif  // GOOGLE_PROTOBUF_COMMON_H__
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.9</a></td></tr>
  </table>
  <br>

</body>
</html>
